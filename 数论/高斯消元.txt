//待修改//普通整数gauss a[n][n]*x[n]=b[n] (mod p);//true返回唯一整数解 a[i][i]*xi = b[i], false非唯一bool gauss(int n){    int i,j,row=1,col=1;    LL t1,t2,maxi;    while(row <=n && col <=n){        for(i=row,j=-1,maxi = 0; i<=n; i++)            if(labs(a[i][col]) > maxi){                j = i;                maxi = labs(a[i][col]);            }        if(j == -1) return false;        for(i=col; i<=n; i++)            swap(a[row][i],a[j][i]);        swap(b[row],b[j]);        t1 = a[row][col];        for(i=row+1; i<=n; i++){            t2 = a[i][col];            for(j = col; j<=n; j++)                a[i][j] = (a[i][j]*t1 - a[row][j]*t2+p)%p;            b[i] = (b[i]*t1-b[row]*t2+p)%p;        }        row++,col++;    }    for(i = n; i>=1; i--){        LL sum = 0;        for(j = i+1; j <= n; j++)            sum = (sum + a[i][j]*ans[j])%p;        ans[i] = find(a[i][i],b[i]-sum);    }    return true;}//待修改2//整数高斯//-2表示有浮点数解，但无整数解，-1表示无解，0表示唯一解，大于0表示无穷解，并返回自由变元的个数int gauss(int equ,int var,int p){    int i,j,row,col,maxr;    for(row=col=1; row<=equ && col<=var; row++,col++)    {        for(maxr=i=row; i<=equ; i++)            if(labs(a[i][col]) > labs(a[row][col]))                maxr = i;        if (maxr != row)            for (j=col; j<=var+1; j++)                swap(a[row][j], a[maxr][j]);        if (!a[row][col])   {row--;continue;}        for(i=row+1; i<=equ; i++)        {            if(a[i][col])            {                LL LCM = lcm(labs(a[row][col]),labs(a[i][col]));                LL ta = LCM / labs(a[i][col]), tb = LCM / labs(a[row][col]);                if (a[i][col]*a[row][col] < 0) tb = -tb;                for (j = col; j <= var+1; j++)                    a[i][j] = (a[i][j]*ta - a[row][j]*tb+p)%p;					//模2用位运算					//a[i][j]^=a[row][j];					            }        }    }    for (i=row; i <= equ; i++)        if (a[i][col])            return -1;    if (row-1 < var)        return var-row+1;    for(i=row-1; i>=1; i--)    {        LL sum = 0;        for(j = i+1; j<=var; j++)            sum = (sum + a[i][j]*ans[j])%p;        a[i][var+1] = ((a[i][var+1]-sum)%p+p)%p;        ans[i] = MLES(a[i][i],a[i][var+1],p);    }    return 0;}//网上#include <iostream>#include <string>#include <cmath>using namespace std;const int maxn = 105;int equ, var; // 有equ个方程，var个变元。增广阵行数为equ, 分别为0到equ - 1，列数为var + 1，分别为0到var.int a[maxn][maxn];int x[maxn]; // 解集.bool free_x[maxn]; // 判断是否是不确定的变元.int free_num;void Debug(void){    int i, j;    for (i = 0; i < equ; i++)    {        for (j = 0; j < var + 1; j++)        {            cout << a[i][j] << " ";        }        cout << endl;    }    cout << endl;}inline int gcd(int a, int b){    int t;    while (b != 0)    {        t = b;        b = a % b;        a = t;    }    return a;}inline int lcm(int a, int b){    return a * b / gcd(a, b);}// 高斯消元法解方程组(Gauss-Jordan elimination).(-2表示有浮点数解，但无整数解，-1表示无解，0表示唯一解，大于0表示无穷解，并返回自由变元的个数)int Gauss(void){    int i, j, k;    int max_r; // 当前这列绝对值最大的行.int col; // 当前处理的列.    int ta, tb;    int LCM;    int temp;    int free_x_num;    int free_index;    // 转换为阶梯阵.    col = 0; // 当前处理的列.    for (k = 0; k < equ && col < var; k++, col++)    { // 枚举当前处理的行.        // 找到该col列元素绝对值最大的那行与第k行交换.(为了在除法时减小误差)        max_r = k;        for (i = k + 1; i < equ; i++)        {            if (abs(a[i][col]) > abs(a[max_r][col])) max_r = i;        }        if (max_r != k)        { // 与第k行交换.            for (j = k; j < var + 1; j++) swap(a[k][j], a[max_r][j]);        }        if (a[k][col] == 0)        { // 说明该col列第k行以下全是0了，则处理当前行的下一列.            k--; continue;        }        for (i = k + 1; i < equ; i++)        { // 枚举要删去的行.            if (a[i][col] != 0)    {                LCM = lcm(abs(a[i][col]), abs(a[k][col]));                ta = LCM / abs(a[i][col]), tb = LCM / abs(a[k][col]);                if (a[i][col] * a[k][col] < 0) tb = -tb; // 异号的情况是两个数相加.                for (j = col; j < var + 1; j++)                {                    a[i][j] = a[i][j] * ta - a[k][j] * tb;                }    }        }    }    Debug();    // 1. 无解的情况: 化简的增广阵中存在(0, 0, ..., a)这样的行(a != 0).    for (i = k; i < equ; i++)    { // 对于无穷解来说，如果要判断哪些是自由变元，那么初等行变换中的交换就会影响，则要记录交换.        if (a[i][col] != 0) return -1;    }    // 2. 无穷解的情况: 在var * (var + 1)的增广阵中出现(0, 0, ..., 0)这样的行，即说明没有形成严格的上三角阵.    // 且出现的行数即为自由变元的个数.    if (k < var)    {        // 首先，自由变元有var - k个，即不确定的变元至少有var - k个.        for (i = k - 1; i >= 0; i--)        {            // 第i行一定不会是(0, 0, ..., 0)的情况，因为这样的行是在第k行到第equ行.            // 同样，第i行一定不会是(0, 0, ..., a), a != 0的情况，这样的无解的.            free_x_num = 0; // 用于判断该行中的不确定的变元的个数，如果超过1个，则无法求解，它们仍然为不确定的变元.            for (j = 0; j < var; j++)            {                if (a[i][j] != 0 && free_x[j]) free_x_num++, free_index = j;            }            if (free_x_num > 1) continue; // 无法求解出确定的变元.            // 说明就只有一个不确定的变元free_index，那么可以求解出该变元，且该变元是确定的.            temp = a[i][var];            for (j = 0; j < var; j++)            {                if (a[i][j] != 0 && j != free_index) temp -= a[i][j] * x[j];            }            x[free_index] = temp / a[i][free_index]; // 求出该变元.            free_x[free_index] = 0; // 该变元是确定的.        }        return var - k; // 自由变元有var - k个.    }    // 3. 唯一解的情况: 在var * (var + 1)的增广阵中形成严格的上三角阵.    // 计算出Xn-1, Xn-2 ... X0.    for (i = var - 1; i >= 0; i--)    {        temp = a[i][var];        for (j = i + 1; j < var; j++)        {            if (a[i][j] != 0) temp -= a[i][j] * x[j];        }        if (temp % a[i][i] != 0) return -2; // 说明有浮点数解，但无整数解.        x[i] = temp / a[i][i];    }return 0;}int main(void){    freopen("Input.txt", "r", stdin);    int i, j;    while (scanf("%d %d", &equ, &var) != EOF)    {        memset(a, 0, sizeof(a));   memset(x, 0, sizeof(x));   memset(free_x, 1, sizeof(free_x)); // 一开始全是不确定的变元.        for (i = 0; i < equ; i++)        {            for (j = 0; j < var + 1; j++)            {                scanf("%d", &a[i][j]);            }        }//        Debug();        free_num = Gauss();        if (free_num == -1) printf("无解!\n");   else if (free_num == -2) printf("有浮点数解，无整数解!\n");        else if (free_num > 0)        {            printf("无穷多解! 自由变元个数为%d\n", free_num);            for (i = 0; i < var; i++)            {                if (free_x[i]) printf("x%d 是不确定的\n", i + 1);                else printf("x%d: %d\n", i + 1, x[i]);            }        }        else        {            for (i = 0; i < var; i++)            {                printf("x%d: %d\n", i + 1, x[i]);            }        }        printf("\n");    }    return 0;}